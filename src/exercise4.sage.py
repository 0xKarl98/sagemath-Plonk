

# This file was *autogenerated* from the file exercise4.sage
from sage.all_cmdline import *   # import sage library

_sage_const_21888242871839275222246405745257275088548364400416034343698204186575808495617 = Integer(21888242871839275222246405745257275088548364400416034343698204186575808495617); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_9 = Integer(9)# Import necessary definitions from previous exercises
p = _sage_const_21888242871839275222246405745257275088548364400416034343698204186575808495617 
F = GF(p)
R = PolynomialRing(F, 'x', names=('x',)); (x,) = R._first_ngens(1)

# Define interpolation function
def interpolate(I, Y):
    n = len(I)
    f = _sage_const_0 
    for j in range(n):
        L_j = _sage_const_1 
        for i in range(n):
            if i != j:
                L_j *= (x - I[i]) / (I[j] - I[i])
        f += Y[j] * L_j
    return f

# Variable definitions from previous exercises
I = [_sage_const_1 ,_sage_const_2 ,_sage_const_3 ,_sage_const_4 ]
a = {_sage_const_1 :_sage_const_0 ,_sage_const_2 :_sage_const_1 ,_sage_const_3 :_sage_const_1 ,_sage_const_4 :_sage_const_3 }  # Left input values
b = {_sage_const_1 :_sage_const_1 ,_sage_const_2 :_sage_const_1 ,_sage_const_3 :_sage_const_2 ,_sage_const_4 :_sage_const_3 }  # Right input values
c = {_sage_const_1 :_sage_const_1 ,_sage_const_2 :_sage_const_2 ,_sage_const_3 :_sage_const_3 ,_sage_const_4 :_sage_const_9 }  # Output values

# Selector polynomials
SL = {_sage_const_1 :_sage_const_1 ,_sage_const_2 :_sage_const_1 ,_sage_const_3 :_sage_const_1 ,_sage_const_4 :_sage_const_0 }
SR = {_sage_const_1 :_sage_const_1 ,_sage_const_2 :_sage_const_1 ,_sage_const_3 :_sage_const_1 ,_sage_const_4 :_sage_const_0 }
SM = {_sage_const_1 :_sage_const_0 ,_sage_const_2 :_sage_const_0 ,_sage_const_3 :_sage_const_0 ,_sage_const_4 :_sage_const_1 }

qL = interpolate(I, list(SL.values()))
qR = interpolate(I, list(SR.values()))
qM = interpolate(I, list(SM.values()))

# Interpolate input/output polynomials
a_poly = interpolate(I, list(a.values()))
b_poly = interpolate(I, list(b.values()))
c_poly = interpolate(I, list(c.values()))

# Define constraint polynomial t(x) = qL(x)*a(x) + qR(x)*b(x) + qM(x)*a(x)*b(x) - c(x)
t = qL * a_poly + qR * b_poly + qM * a_poly * b_poly - c_poly

# Define recursive constraint polynomials f1 and f2
# f1: For i in {1,2}: a(i+1) = b(i) 
# f2: For i in {1,2}: b(i+1) = c(i)
f1_values = []
f2_values = []
for i in I:
    if i <= _sage_const_2 :  # For i in {1,2}
        f1_values.append(a[i+_sage_const_1 ] - b[i])  # a(i+1) - b(i) should be 0
        f2_values.append(b[i+_sage_const_1 ] - c[i])  # b(i+1) - c(i) should be 0
    else:
        f1_values.append(_sage_const_0 )  # No constraint for i=3,4
        f2_values.append(_sage_const_0 )  # No constraint for i=3,4

f1 = interpolate(I, f1_values)
f2 = interpolate(I, f2_values)

# Compute vanishing polynomial Z(x) = ∏(x - i) for i in I
Z = R(_sage_const_1 )  # Start with the constant polynomial 1
for i in I:
    Z *= (x - i)

# Compute quotient polynomial Q(x) such that t(x) = Q(x) * Z(x)
Q = t // Z

# Compute Z1(x) for I' = I \ {3,4} = {1,2}
I_prime = [_sage_const_1 , _sage_const_2 ]
Z1 = R(_sage_const_1 )
for i in I_prime:
    Z1 *= (x - i)

# Compute quotient polynomials Q1(x) and Q2(x)
Q1 = f1 // Z1
Q2 = f2 // Z1

# Verification as shown in the PLONK tutorial
print("=== Verification Results ===")
print("Is t(x) = Q(x) * Z(x)?", t == Q*Z)
show("Q=", Q)
print("Is f1(x) = Q1(x) * Z1(x)?", f1 == Q1*Z1)
show("Q1=", Q1)
print("Is f2(x) = Q2(x) * Z1(x)?", f2 == Q2*Z1)
show("Q2=", Q2)

